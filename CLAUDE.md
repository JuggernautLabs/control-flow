The character.txt file contains information about llm behavior, we are going to build a system leveraging that behavior -- to get started we need a few things
1. low level client trait -- should at least have 'ask_raw(string)string|error' but can include anything you think might be important. 
2. implement a trait method with retry logic on errors before forwarding the error to the caller, and verifies a particular json response output structure (the function has a generic return), if there is a failure implement retry logic which describes the failure mode (through the error) and send that as context to the model along with the previous message. Number of retries per type should be a configuration of the client
3. application level clients should now be able to make a call to the low level client, expecting a particular data type and ? unwrap it guaranteeing that data and retries or a QueryResolverError, which can contain AIError, which then contains the particular (claude|openai|etc)*(api error (http|idk|etc)) 
4. given the format of a ticket decomposition, we can now get to work extracting specific information. Given a section of a ticket we must complete certain work. If a term needs refinement, then we need to refine the term. That work should be passed to an application level client, which accepts a particular AiClient (which the QueryResolver implements); So a refinement is a call to client which should produce another ticket with the express purpose of zooming in on a techical specification of the particular term of interest. 
let's first work on a refinement, but leave space for other implementations. 