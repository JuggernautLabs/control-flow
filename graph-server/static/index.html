<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Graph API</title>
    <script src="https://unpkg.com/d3@7"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .control-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        input, button, select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button.danger {
            background: #dc3545;
        }
        
        button.danger:hover {
            background: #c82333;
        }
        
        #graph {
            width: 100%;
            height: 600px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .node {
            stroke: #333;
            stroke-width: 2px;
            cursor: pointer;
        }
        
        .link {
            stroke: #999;
            stroke-width: 2px;
            stroke-opacity: 0.8;
        }
        
        .node-label {
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            fill: #333;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Simple Graph Rendering API</h1>
        <p>Clean implementation focusing on basic graph functionality</p>
        
        <div class="controls">
            <div class="control-row">
                <input id="nodeLabel" placeholder="Node Label" />
                <input id="nodeColor" placeholder="Color (optional)" />
                <button onclick="addNode()">Add Node</button>
            </div>
            
            <div class="control-row">
                <select id="sourceNode">
                    <option value="">Select Source</option>
                </select>
                <select id="targetNode">
                    <option value="">Select Target</option>
                </select>
                <input id="edgeLabel" placeholder="Edge Label (optional)" />
                <button onclick="addEdge()">Add Edge</button>
            </div>
            
            <div class="control-row">
                <button onclick="refreshGraph()">Refresh</button>
                <button onclick="generateSampleData()">Sample Data</button>
                <button onclick="clearGraph()" class="danger">Clear All</button>
            </div>
            
            <div class="control-row">
                <span>Zoom:</span>
                <button onclick="zoomIn()">Zoom In</button>
                <button onclick="zoomOut()">Zoom Out</button>
                <button onclick="resetZoom()">Reset Zoom</button>
                <span id="zoomLevel">1.0x</span>
            </div>
        </div>
        
        <svg id="graph"></svg>
        
        <div id="status" class="status" style="display: none;"></div>
    </div>

    <script>
        // Simple Graph Renderer - Clean Implementation
        class SimpleGraphRenderer {
            constructor(svgId, width = 1160, height = 600) {
                this.width = width;
                this.height = height;
                this.svg = d3.select(svgId)
                    .attr('width', width)
                    .attr('height', height);
                
                this.container = this.svg.append('g').attr('class', 'zoom-container');
                this.nodes = [];
                this.links = [];
                this.currentZoom = 1.0;
                
                this.initZoom();
                this.initSimulation();
            }
            
            initZoom() {
                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 10])
                    .on('zoom', (event) => {
                        this.currentZoom = event.transform.k;
                        this.container.attr('transform', event.transform);
                        this.updateZoomDisplay();
                    });
                
                this.svg.call(this.zoom);
            }
            
            initSimulation() {
                this.simulation = d3.forceSimulation()
                    .force('link', d3.forceLink()
                        .id(d => d.id)
                        .distance(100)
                        .strength(0.5))
                    .force('charge', d3.forceManyBody().strength(-300))
                    .force('center', d3.forceCenter(this.width / 2, this.height / 2))
                    .force('collision', d3.forceCollide().radius(25));
            }
            
            updateZoomDisplay() {
                const zoomElement = document.getElementById('zoomLevel');
                if (zoomElement) {
                    zoomElement.textContent = `${this.currentZoom.toFixed(1)}x`;
                }
            }
            
            setData(nodes, links) {
                // Store data copies
                this.nodes = nodes.map(d => ({...d}));
                this.links = links.map(d => ({...d}));
                
                console.log('Setting data:', this.nodes.length, 'nodes,', this.links.length, 'links');
                
                this.render();
            }
            
            render() {
                // Clear previous render
                this.container.selectAll('*').remove();
                
                // Create links first (so they appear behind nodes)
                const link = this.container.append('g')
                    .selectAll('line')
                    .data(this.links)
                    .enter()
                    .append('line')
                    .attr('class', 'link')
                    .style('stroke', d => d.color || '#999');
                
                // Create nodes
                const node = this.container.append('g')
                    .selectAll('circle')
                    .data(this.nodes)
                    .enter()
                    .append('circle')
                    .attr('class', 'node')
                    .attr('r', d => d.size || 20)
                    .style('fill', d => d.color || '#69b3a2')
                    .call(d3.drag()
                        .on('start', (event, d) => this.dragstarted(event, d))
                        .on('drag', (event, d) => this.dragged(event, d))
                        .on('end', (event, d) => this.dragended(event, d)));
                
                // Create labels
                const label = this.container.append('g')
                    .selectAll('text')
                    .data(this.nodes)
                    .enter()
                    .append('text')
                    .attr('class', 'node-label')
                    .text(d => d.label);
                
                // Update simulation
                this.simulation.nodes(this.nodes);
                this.simulation.force('link').links(this.links);
                
                // Set up tick handler
                this.simulation.on('tick', () => {
                    // Update links
                    link
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);
                    
                    // Update nodes
                    node
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);
                    
                    // Update labels
                    label
                        .attr('x', d => d.x)
                        .attr('y', d => d.y + 4);
                });
                
                // Restart simulation
                this.simulation.alpha(1).restart();
            }
            
            dragstarted(event, d) {
                if (!event.active) this.simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            dragended(event, d) {
                if (!event.active) this.simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // Zoom control methods
            zoomIn() {
                this.svg.transition().duration(300).call(
                    this.zoom.scaleBy, 1.5
                );
            }
            
            zoomOut() {
                this.svg.transition().duration(300).call(
                    this.zoom.scaleBy, 1 / 1.5
                );
            }
            
            resetZoom() {
                this.svg.transition().duration(500).call(
                    this.zoom.transform,
                    d3.zoomIdentity
                );
            }
        }
        
        // Global state
        let renderer = new SimpleGraphRenderer('#graph');
        let graphData = { nodes: {}, edges: {} };
        
        // API functions
        async function apiCall(url, options = {}) {
            try {
                const response = await fetch(url, {
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    ...options
                });
                
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'API call failed');
                }
                
                return data.data;
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                throw error;
            }
        }
        
        async function refreshGraph() {
            try {
                const data = await apiCall('/api/graph');
                graphData = data;
                updateGraph();
                showStatus('Graph refreshed successfully', 'success');
            } catch (error) {
                console.error('Failed to refresh graph:', error);
            }
        }
        
        function updateGraph() {
            const nodes = Object.values(graphData.nodes || {});
            const links = Object.values(graphData.edges || {});
            
            renderer.setData(nodes, links);
            updateDropdowns();
        }
        
        function updateDropdowns() {
            const sourceSelect = document.getElementById('sourceNode');
            const targetSelect = document.getElementById('targetNode');
            
            // Clear existing options
            sourceSelect.innerHTML = '<option value="">Select Source</option>';
            targetSelect.innerHTML = '<option value="">Select Target</option>';
            
            // Add node options
            Object.values(graphData.nodes || {}).forEach(node => {
                const option1 = document.createElement('option');
                option1.value = node.id;
                option1.textContent = `${node.label} (${node.id})`;
                sourceSelect.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = node.id;
                option2.textContent = `${node.label} (${node.id})`;
                targetSelect.appendChild(option2);
            });
        }
        
        async function addNode() {
            const label = document.getElementById('nodeLabel').value.trim();
            const color = document.getElementById('nodeColor').value.trim();
            
            if (!label) {
                showStatus('Please enter a node label', 'error');
                return;
            }
            
            try {
                const nodeData = {
                    label: label,
                    ...(color && { color: color })
                };
                
                const data = await apiCall('/api/nodes', {
                    method: 'POST',
                    body: JSON.stringify(nodeData)
                });
                
                graphData.nodes[data.id] = data;
                updateGraph();
                
                // Clear inputs
                document.getElementById('nodeLabel').value = '';
                document.getElementById('nodeColor').value = '';
                
                showStatus(`Node "${data.label}" added successfully`, 'success');
            } catch (error) {
                console.error('Failed to add node:', error);
            }
        }
        
        async function addEdge() {
            const source = document.getElementById('sourceNode').value;
            const target = document.getElementById('targetNode').value;
            const label = document.getElementById('edgeLabel').value.trim();
            
            if (!source || !target) {
                showStatus('Please select both source and target nodes', 'error');
                return;
            }
            
            try {
                const edgeData = {
                    source: source,
                    target: target,
                    ...(label && { label: label })
                };
                
                const data = await apiCall('/api/edges', {
                    method: 'POST',
                    body: JSON.stringify(edgeData)
                });
                
                graphData.edges[data.id] = data;
                updateGraph();
                
                // Clear inputs
                document.getElementById('sourceNode').value = '';
                document.getElementById('targetNode').value = '';
                document.getElementById('edgeLabel').value = '';
                
                showStatus('Edge added successfully', 'success');
            } catch (error) {
                console.error('Failed to add edge:', error);
            }
        }
        
        async function clearGraph() {
            if (!confirm('Are you sure you want to clear all nodes and edges?')) return;
            
            try {
                await apiCall('/api/clear', { method: 'POST' });
                graphData = { nodes: {}, edges: {} };
                updateGraph();
                showStatus('Graph cleared successfully', 'success');
            } catch (error) {
                console.error('Failed to clear graph:', error);
            }
        }
        
        async function generateSampleData() {
            try {
                // Add sample nodes
                const sampleNodes = [
                    { label: 'Node A', color: '#ff6b6b' },
                    { label: 'Node B', color: '#4ecdc4' },
                    { label: 'Node C', color: '#45b7d1' },
                    { label: 'Node D', color: '#96ceb4' }
                ];
                
                const nodeIds = [];
                for (const nodeData of sampleNodes) {
                    const data = await apiCall('/api/nodes', {
                        method: 'POST',
                        body: JSON.stringify(nodeData)
                    });
                    graphData.nodes[data.id] = data;
                    nodeIds.push(data.id);
                }
                
                // Add sample edges
                const sampleEdges = [
                    { source: nodeIds[0], target: nodeIds[1], label: 'connects' },
                    { source: nodeIds[1], target: nodeIds[2], label: 'flows to' },
                    { source: nodeIds[2], target: nodeIds[3], label: 'leads to' },
                    { source: nodeIds[3], target: nodeIds[0], label: 'returns to' }
                ];
                
                for (const edgeData of sampleEdges) {
                    const data = await apiCall('/api/edges', {
                        method: 'POST',
                        body: JSON.stringify(edgeData)
                    });
                    graphData.edges[data.id] = data;
                }
                
                updateGraph();
                showStatus('Sample data generated successfully', 'success');
            } catch (error) {
                console.error('Failed to generate sample data:', error);
            }
        }
        
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 5000);
        }
        
        // Zoom control functions
        function zoomIn() {
            renderer.zoomIn();
        }
        
        function zoomOut() {
            renderer.zoomOut();
        }
        
        function resetZoom() {
            renderer.resetZoom();
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            refreshGraph();
        });
    </script>
</body>
</html>